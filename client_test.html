<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SignSense WebRTC DataChannel Test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 1.2rem; background:#111; color:#eee; }
    h1 { font-size:1.4rem; margin:0 0 .5rem; }
    fieldset { border:1px solid #444; margin-bottom:1rem; }
    legend { padding:0 .4rem; }
    label { display:inline-block; min-width:130px; }
    input[type=number] { width:90px; }
    button { margin:.2rem .4rem .2rem 0; padding:.5rem .9rem; background:#1e88e5; color:#fff; border:none; border-radius:4px; cursor:pointer; }
    button:disabled { background:#555; cursor:not-allowed; }
    pre { background:#000; padding:.6rem; overflow:auto; max-height:320px; font-size:.8rem; }
    #videoContainer { display:flex; gap:1rem; flex-wrap:wrap; }
    video, canvas { background:#222; max-width:320px; width:320px; }
    .row { margin-bottom:.5rem; }
    .badge { display:inline-block; padding:2px 6px; background:#444; margin-right:4px; border-radius:3px; font-size:.7rem; }
    .ok { color:#4caf50; }
    .warn { color:#ff9800; }
    .err { color:#f44336; }
    #statusLine { font-size:.85rem; margin-top:.4rem; }
    table.stats { border-collapse:collapse; margin-top:.5rem; }
    table.stats td { padding:2px 6px; font-size:.75rem; border:1px solid #333; }
    a { color:#90caf9; }
  </style>
</head>
<body>
<h1>SignSense DataChannel Frame Sender</h1>
<p style="font-size:.85rem; line-height:1.3;">브라우저 카메라를 캡처하여 JPEG 프레임을 WebRTC DataChannel 로 전송하고, 서버 추론(더미) 결과를 WebSocket 메시지로 수신합니다.<br>
현재 서버는 Trickle ICE 를 사용하지 않고 Offer/Answer 1회 교환 방식입니다.</p>

<fieldset>
  <legend>연결 / 제어</legend>
  <div class="row">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <button id="btnStart" disabled>Start Capture</button>
    <button id="btnStop" disabled>Stop Capture</button>
    <button id="btnFlush" disabled>Flush(강제결과)</button>
  </div>
  <div class="row" id="statusLine">Status: <span id="status">idle</span></div>
</fieldset>

<fieldset>
  <legend>파라미터</legend>
  <div class="row"><label for="interval">Frame Interval(ms)</label><input id="interval" type="number" value="33" min="33" step="1" /></div>
  <div class="row"><label for="quality">JPEG Quality (0~1)</label><input id="quality" type="number" value="0.7" min="0.05" max="1" step="0.05" /></div>
  <div class="row"><label for="collectionTime">Collection Time (s)</label><input id="collectionTime" type="number" value="5.0" min="1" step="0.1" /></div>
  <div class="row"><label for="maxFrames">Max Frames (Safety)</label><input id="maxFrames" type="number" value="300" min="1" step="1" /></div>
  <div class="row"><button id="btnLoadConfig">서버 /config 반영</button></div>
</fieldset>

<fieldset>
  <legend>미디어</legend>
  <div id="videoContainer">
    <div>
      <div style="font-size:.75rem;">Local Camera</div>
      <video id="video" autoplay playsinline muted></video>
    </div>
    <div>
      <div style="font-size:.75rem;">Capture Canvas (전송 소스)</div>
      <canvas id="canvas" width="320" height="240"></canvas>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>실시간 전송 상태</legend>
  <table class="stats">
    <tr><td>Sent Frames</td><td id="sentFrames">0</td></tr>
    <tr><td>Last Frame bytes</td><td id="lastBytes">0</td></tr>
    <tr><td>Total Bytes</td><td id="totalBytes">0</td></tr>
    <tr><td>Avg FPS (approx)</td><td id="avgFps">0</td></tr>
    <tr><td>Elapsed (s)</td><td id="elapsed">0</td></tr>
  </table>
</fieldset>

<fieldset>
  <legend>메시지 로그</legend>
  <pre id="log"></pre>
</fieldset>

<script>
(function(){
  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  function log(msg, cls){
    const time = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = '['+time+'] '+ msg;
    if(cls) line.className = cls;
    logEl.append(line);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(s){ statusEl.textContent = s; }

  // Elements
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnFlush = document.getElementById('btnFlush');
  const btnLoadConfig = document.getElementById('btnLoadConfig');
  const intervalInput = document.getElementById('interval');
  const qualityInput = document.getElementById('quality');
  const collectionTimeInput = document.getElementById('collectionTime');
  const maxFramesInput = document.getElementById('maxFrames');

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const sentFramesEl = document.getElementById('sentFrames');
  const lastBytesEl = document.getElementById('lastBytes');
  const totalBytesEl = document.getElementById('totalBytes');
  const avgFpsEl = document.getElementById('avgFps');
  const elapsedEl = document.getElementById('elapsed');

  let pc = null;
  let dc = null;
  let ws = null;
  let captureTimer = null;
  let stopTimer = null; // 캡처 자동 중지 타이머
  let startTs = 0;
  let sentFrames = 0;
  let totalBytes = 0;
  let stopped = true;

  async function initMedia(){
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio:false });
      video.srcObject = stream;
      await new Promise(r=>video.onloadedmetadata = r);
      log('카메라 스트림 획득','ok');
    } catch(e){
      log('카메라 접근 실패: '+ e,'err');
      throw e;
    }
  }

  function createPeer(){
    pc = new RTCPeerConnection({
      iceServers: [
        { urls: ['stun:stun.l.google.com:19302'] }
      ]
    });

    pc.onicegatheringstatechange = () => {
      log('ICE Gathering: '+ pc.iceGatheringState);
      if(pc.iceGatheringState === 'complete'){
        // Send offer after gathering (no trickle)
        sendOffer();
      }
    };

    pc.onconnectionstatechange = () => {
      log('PC state: '+ pc.connectionState);
      if(['failed','disconnected','closed'].includes(pc.connectionState)){
        setStatus('pc_'+pc.connectionState);
      }
    };

    dc = pc.createDataChannel('frames');
    dc.binaryType = 'arraybuffer';
    dc.onopen = () => { log('DataChannel opened','ok'); btnStart.disabled=false; btnFlush.disabled=false; };
    dc.onclose = () => { log('DataChannel closed','warn'); btnStart.disabled=true; btnFlush.disabled=true; };
    dc.onerror = (e) => { log('DataChannel error:'+ e,'err'); };
  }

  async function sendOffer(){
    if(!pc) return;
    const localDesc = pc.localDescription;
    if(!localDesc){ log('Offer 없음?','err'); return; }
    if(ws && ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify({ action:'offer', sdp: localDesc.sdp, type: localDesc.type }));
      log('Offer 전송');
    }
  }

  async function connect(){
    setStatus('connecting');
    const sessionId = 'client_' + Date.now();
    ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/' + sessionId);
    ws.onopen = () => { log('WebSocket 연결','ok'); };
    ws.onerror = (e) => { log('WebSocket 에러:[object Event]','err'); console.error(e); };
    ws.onclose = (e) => { log(`WebSocket 종료. Code: ${e.code}, Reason: ${e.reason}`,'warn'); setStatus('ws_closed'); };
    ws.onmessage = async (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        if(msg.type === 'answer'){ // 'action' 대신 'type'을 사용하도록 수정
          log('Answer 수신');
          await pc.setRemoteDescription({ type: msg.type, sdp: msg.sdp });
          setStatus('connected');
          btnDisconnect.disabled = false;
        } else if(msg.type === 'inference_result'){ // 'result' 대신 'inference_result'를 사용하도록 수정
          log('Inference 결과 수신: '+ JSON.stringify(msg.data));
          // 추론 완료 후 리셋 준비
          setStatus('inference_done');
          log('추론 완료. 1초 후 다음 캡처를 위해 리셋합니다.');
          setTimeout(resetForNextCapture, 1000);
        } else if(msg.type === 'error'){
          log('Server Error: '+ msg.error,'err');
        } else if(msg.action === 'pong'){
          // ignore
        }
      } catch(e){
        log('메시지 파싱 실패: '+ e,'err');
      }
    };

    createPeer();
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
  }

  function disconnect(){
    stopCapture();
    if(dc){ try{ dc.close(); }catch(_){} }
    if(pc){ try{ pc.close(); }catch(_){} }
    if(ws && ws.readyState === WebSocket.OPEN){ ws.close(); }
    pc = null; dc = null; ws = null;
    btnDisconnect.disabled=true;
    btnStart.disabled=true;
    btnStop.disabled=true;
    btnFlush.disabled=true;
    btnConnect.disabled=false;
    setStatus('idle');
    log('연결 해제 완료','warn');
  }

  function updateStats(){
    const now = performance.now();
    const elapsedMs = now - startTs;
    const fps = sentFrames / (elapsedMs/1000 || 1);
    sentFramesEl.textContent = sentFrames;
    totalBytesEl.textContent = totalBytes;
    avgFpsEl.textContent = fps.toFixed(2);
    elapsedEl.textContent = (elapsedMs/1000).toFixed(1);
  }

  function scheduleNext(){
    const interval = parseInt(intervalInput.value,10) || 150;
    captureTimer = setTimeout(captureFrame, interval);
  }

  function captureFrame(){
    if(stopped || !dc || dc.readyState !== 'open') return;
    try {
      const vw = video.videoWidth || 640;
      const vh = video.videoHeight || 480;
      canvas.width = 320; // downscale
      canvas.height = Math.round(320 * (vh/vw));
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const q = Math.min(1, Math.max(0.05, parseFloat(qualityInput.value)||0.7));
      canvas.toBlob(async (blob) => {
        if(!blob) { scheduleNext(); return; }
        const arr = new Uint8Array(await blob.arrayBuffer());
        if(dc && dc.readyState === 'open' && !stopped){
          dc.send(arr);
          sentFrames++;
          totalBytes += arr.byteLength;
          lastBytesEl.textContent = arr.byteLength;
          updateStats();

          // 안전장치: 최대 프레임 수 도달 시 중지
          const maxFrames = parseInt(maxFramesInput.value,10) || 300;
          if(sentFrames >= maxFrames){
            log('최대 프레임(안전장치) 도달. 전송 중지.');
            stopCapture(false); // keep connection for result
          } else {
            scheduleNext();
          }
        }
      }, 'image/jpeg', q);
    } catch(e){
      log('캡처 실패: '+ e,'err');
      scheduleNext();
    }
  }

  function startCapture(){
    if(!dc || dc.readyState !== 'open'){
      log('DataChannel 이 아직 open 상태가 아님','warn');
      return;
    }
    stopped = false;
    sentFrames = 0;
    totalBytes = 0;
    startTs = performance.now();
    btnStart.disabled=true;
    btnStop.disabled=false;

    // 설정된 시간 후에 자동으로 캡처를 중지하는 타이머 설정
    const collectionTime = parseFloat(collectionTimeInput.value) || 5.0;
    log(`캡처 시작. ${collectionTime}초 후에 자동으로 중지됩니다.`);
    stopTimer = setTimeout(() => {
        log('설정된 시간 도달. 전송 중지 및 추론 요청.');
        stopCapture(false); // 수동 중지가 아님
    }, collectionTime * 1000);

    captureFrame();
    setStatus('capturing');
  }

  function stopCapture(manual=true){
    if (stopped) return; // 중복 호출 방지
    stopped = true;
    if(captureTimer){ clearTimeout(captureTimer); captureTimer=null; }
    if(stopTimer){ clearTimeout(stopTimer); stopTimer=null; } // 자동 중지 타이머도 클리어
    btnStop.disabled=true;

    // 수동으로 중지할 때만 Start 버튼을 즉시 활성화
    if (manual && dc && dc.readyState === 'open') {
        btnStart.disabled = false;
    }

    if(manual) {
      log('캡처 수동 중지');
      setStatus('connected');
    } else {
      // 자동 중지 시 flush 신호 전송
      flush();
    }
  }

  function flush(){
    if(dc && dc.readyState === 'open'){
      dc.send('flush');
      log('flush 전송');
    }
  }

  function resetForNextCapture() {
    if (dc && dc.readyState === 'open') {
        dc.send('reset');
        log('서버에 리셋 신호 전송');
        btnStart.disabled = false;
        setStatus('connected');
        log('준비 완료. 다시 캡처를 시작할 수 있습니다.');
    }
  }

  async function loadConfig(){
    try {
      const r = await fetch('/config');
      if(!r.ok) throw new Error('http '+ r.status);
      const cfg = await r.json();
      if(cfg.collection_duration_seconds) {
        collectionTimeInput.value = cfg.collection_duration_seconds;
      }
      if(cfg.max_frames_to_collect) {
        maxFramesInput.value = cfg.max_frames_to_collect;
      }
      log(`서버 config 적용: CollectionTime=${collectionTimeInput.value}s, MaxFrames=${maxFramesInput.value}`);
    } catch(e){
      log('/config 로드 실패: '+ e,'err');
    }
  }

  btnConnect.onclick = async () => {
    btnConnect.disabled = true;
    btnDisconnect.disabled = false;
    try {
      await initMedia();
      await connect();
    } catch(e){
      log('연결 실패: '+ e,'err');
      btnConnect.disabled=false; btnDisconnect.disabled=true;
    }
  };
  btnDisconnect.onclick = disconnect;
  btnStart.onclick = startCapture;
  btnStop.onclick = () => stopCapture(true);
  btnFlush.onclick = flush;
  btnLoadConfig.onclick = loadConfig;

  // Ping every 30s to keep ws alive (optional)
  setInterval(()=>{ if(ws && ws.readyState===WebSocket.OPEN){ ws.send(JSON.stringify({action:'ping'})); } }, 30000);

})();
</script>
</body>
</html>
