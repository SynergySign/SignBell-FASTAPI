# 🚀 WebRTC 기반 실시간 수어 인식 FAST API 구축 순서

## 💡 단계 0: HTTPS 개발 환경 구축 (필수)

WebRTC 사용 및 모바일 카메라 접근을 위해 **HTTPS 환경 구축**은 필수 선행 작업입니다. (File Upload 방식과 동일)

| 순서 | 구성 요소 | 설명 |
| :--- | :--- | :--- |
| **0.1. 로컬 SSL 인증서 생성** | **`mkcert`** (권장) | `mkcert`를 사용하여 개발 환경에 필요한 사설 SSL 인증서 파일(`cert.pem`, `key.pem`)을 발급합니다. |
| **0.2. FAST API HTTPS 적용** | **FAST API & Uvicorn** | FAST API 서버를 실행할 때, 발급받은 인증서 파일을 `uvicorn` 실행 옵션에 추가하여 서버를 **HTTPS**로 구동합니다. |
| **0.3. 클라이언트/서버 연결 테스트** | **아이패드 접속** | 아이패드에서 **`https://서버IP:포트`** 형식으로 접속하여 보안 경고 없이 접속되고 카메라 접근 권한 요청이 뜨는지 확인합니다. |

---

## 1. 학습된 모델 관리 및 로드 (FAST API 서버)

모델을 서버 메모리에 상주시켜 추론 시간을 최소화합니다. (File Upload 방식과 동일)

| 순서 | 구성 요소 | 설명 |
| :--- | :--- | :--- |
| **1.1. 모델 최적화 및 저장** | **추론용 모델 파일** | 학습된 모델을 **추론에 최적화된 형식**(`.onnx`, `TorchScript` 등)으로 변환하여 저장합니다. |
| **1.2. 모델 파일 배치** | **서버 디렉토리** | 변환된 모델 파일과 MediaPipe 파이프라인 파일을 서버 코드에서 접근 가능한 경로에 배치합니다. |
| **1.3. 서버 시작 시 모델 로드** | **`@app.on_event("startup")`** | FAST API 서버가 **최초 구동될 때 한 번만** MediaPipe 파이프라인과 ML 모델을 메모리에 로드하여 전역으로 초기화합니다. |

---

## 2. WebRTC 데이터 처리 서버 구축 (FAST API + WebRTC 라이브러리)

FAST API 서버에 **WebRTC 연결 및 실시간 데이터 수신 기능**을 통합합니다.

| 순서 | 구성 요소 | 역할 | FAST API 통합 방안 |
| :--- | :--- | :--- | :--- |
| **2.1. 시그널링 엔드포인트 정의** | **`WebSocket /ws`** | 클라이언트와 서버가 연결 정보를 교환하고 DataChannel 연결을 수립하도록 돕는 역할. | **`fastapi`의 WebSocket 통합** 기능을 사용하여 Offer/Answer SDP 정보를 교환합니다. |
| **2.2. WebRTC 라이브러리 통합** | **Python WebRTC (`aiortc` 등)** | DataChannel 연결을 수락하고, 수신되는 **바이너리 프레임 데이터 청크**를 처리하는 로직을 구현합니다. | **DataChannel 서버 역할**을 FAST API 내에서 수행하도록 구현합니다. |
| **2.3. DataChannel 수신 및 재구성** | **프레임 시퀀스 저장 모듈** | DataChannel을 통해 전송되는 바이너리 청크들을 **순서대로 받아서 9~10초 시퀀스**에 맞게 원래의 프레임 이미지로 재조립하여 저장합니다. |
| **2.4. ML 추론 통합** | **MediaPipe & ML 모델 추론** | 재구성된 9~10초 프레임 시퀀스에 대해 MediaPipe 좌표 추출 $\rightarrow$ 좌표 시퀀스 전처리 $\rightarrow$ ML 모델 추론을 **비동기로 실행**하는 로직을 통합합니다. |
| **2.5. 결과 전송 로직** | **JSON 응답** | ML 모델이 유추한 최종 단어를 **WebSocket 연결**을 통해 클라이언트에게 전송하는 로직을 구현합니다. |

---

## 3. 아이패드 실시간 전송 클라이언트 구성 (WebRTC DataChannel)

아이패드에서 카메라 스트림을 프레임으로 가공하여 실시간으로 서버에 전송하는 환경을 준비합니다.

| 순서 | 구성 요소 | 작업 내용 |
| :--- | :--- | :--- |
| **3.1. 클라이언트 페이지 제작 및 안정화** | **HTML/JavaScript (HTTPS & Adapter.js)** | **HTTPS로 접속 가능한** 웹 페이지를 제작하고, `Adapter.js` 등을 활용하여 **MediaStream**을 안정적으로 획득합니다. |
| **3.2. WebRTC 시그널링 구현** | **WebSocket 및 Simple-Peer** | **WebSocket**을 통해 시그널링 서버(`2.1`)에 접속하고, WebRTC 라이브러리(`Simple-Peer` 등)를 사용하여 **Offer/Answer 교환**을 진행하여 DataChannel 연결을 수립합니다. |
| **3.3. **프레임 추출 및 전송 시작** | **Canvas 및 DataChannel** | DataChannel이 **`onopen`**된 후, **첫 프레임 추출 및 DataChannel 전송 시작 시점 ($T_{\text{Start}}$)**을 기록합니다. $\rightarrow$ `MediaStream` 프레임을 **Canvas**로 옮긴 후, 압축(JPEG/PNG)하여 **DataChannel을 통해 실시간 분할 전송(Chunking)** 합니다. |
| **3.4. 최종 응답 시간 측정** | **WebSocket 수신 이벤트** | 서버로부터 최종 유추 단어를 포함한 JSON 응답을 **WebSocket**으로 수신한 시점($T_{\text{End}}$)을 기록합니다. **총 반응 시간($T_{\text{End}} - T_{\text{Start}}$)**을 계산하여 화면에 표시합니다. |

---

## 📊 반응 속도 (Latency) 분석 지표

실시간(B 방식) 환경에서는 특히 서버 내부 처리 시간 측정($T_{\text{Inference}} - T_{\text{Receive}}$)이 중요합니다.

| 지표 | 계산식 | 의미 |
| :--- | :--- | :--- |
| **전체 반응 시간 (Total Latency)** | $T_{\text{End}} - T_{\text{Start}}$ | **최종 목표 지표.** 아이패드 전송 시작부터 결과 수신까지의 총 시간. **9~10초 내** 목표 달성 확인. |
| **데이터 전송 지연 (Transfer Latency)** | $T_{\text{Receive}} - T_{\text{Start}}$ | 9~10초 분량의 프레임 시퀀스가 서버에 도달하는 데 걸리는 시간. 네트워크 및 전송 로직의 효율성 확인. |
| **서버 처리 지연 (Server Processing Latency)** | $T_{\text{Inference}} - T_{\text{Receive}}$ | **성능 최적화 핵심 지표.** MediaPipe 좌표 추출과 ML 추론에 걸리는 순수한 서버 처리 시간. 이 값이 낮을수록 실시간성이 확보됩니다. |